// +build ignore

// gen_sql generates a sql.go file from the SQL tables.
package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
)

const (
	defaultSource = "schema.sql"
	defaultOutput = "sql.go"
)

var quiet bool

func fatalf(format string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, format, args...)
	os.Exit(1)
}

func die(err error) {
	fatalf("%s", err)
}

func info(format string, args ...interface{}) {
	if quiet {
		return
	}
	fmt.Printf(format, args...)
}

func process(in string) string {
	lines := strings.Split(in, "\n")
	out := []string{}

	for i := range lines {
		line := strings.TrimSpace(lines[i])
		if line == "" {
			continue
		}

		if strings.HasPrefix(line, "--") {
			continue
		}

		out = append(out, lines[i])
	}

	if len(out) == 0 {
		return ""
	}

	return fmt.Sprintf("`%s`", strings.Join(out, "\n"))
}

func main() {
	var src, dst string
	var check bool

	flag.BoolVar(&check, "c", false, "check whether the output file is up to date.")
	flag.StringVar(&src, "f", defaultSource, "SQL source file to use.")
	flag.StringVar(&dst, "o", defaultOutput, "Go source file to generate.")
	flag.BoolVar(&quiet, "q", false, "only print errors")
	flag.Parse()

	in, err := ioutil.ReadFile(src)
	if err != nil {
		die(err)
	}

	statements := strings.Split(string(in), "\n\n")
	processed := make([]string, 0, len(statements))
	for i := range statements {
		statement := process(statements[i])
		if statement != "" {
			processed = append(processed, statement)
		}
	}

	sqlVar := fmt.Sprintf("var rawSQL = []string{\n%s,\n}",
		strings.Join(processed, ",\n"))

	code := fmt.Sprintf(`package model

// NOTE: this file is autogenerated using gen_sql.go.

%s
`, sqlVar)

	if check {
		in, err = ioutil.ReadFile(dst)
		if err != nil {
			die(err)
		}

		if string(in) == code {
			info("%s is current.\n", dst)
			os.Exit(0)
		}
		info("%s is out of date.\n", dst)
		os.Exit(1)
	} else {
		err = ioutil.WriteFile(dst, []byte(code), 0644)
		if err != nil {
			die(err)
		}
	}
}
